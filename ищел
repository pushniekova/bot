from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
import liqpay
import os

# Токен бота
TOKEN = '6201719090:AAHVmrXtpwRTD31h2XZtvF29S8sVr2VTOj8'
# Параметри LiqPay
LIQPAY_PUBLIC_KEY = 'YOUR_PUBLIC_KEY'
LIQPAY_PRIVATE_KEY = 'YOUR_PRIVATE_KEY'
LIQPAY_DESCRIPTION = 'Payment for writing work'
LIQPAY_CURRENCY = 'UAH'
LIQPAY_VERSION = '3'
LIQPAY_SANDBOX = True

# Створюємо об'єкт LiqPay
liqpay_instance = liqpay.LiqPay(LIQPAY_PUBLIC_KEY, LIQPAY_PRIVATE_KEY)

# Створюємо об'єкт для збереження інформації про замовлення
class Order:
    def __init__(self, customer_id, work_type, subject, topic, pages, uniqueness, deadline, comment, cost):
        self.customer_id = customer_id
        self.work_type = work_type
        self.subject = subject
        self.topic = topic
        self.pages = pages
        self.uniqueness = uniqueness
        self.deadline = deadline
        self.comment = comment
        self.cost = cost

# Створюємо об'єкт замовлення
order = None

# Функція для створення інформації про замовлення
def create_order_info():
    order_info = f'ID замовника: {order.customer_id}\n'
    order_info += f'Вид роботи: {order.work_type}\n'
    order_info += f'Предмет: {order.subject}\n'
    order_info += f'Тема: {order.topic}\n'
    order_info += f'Кількість сторінок: {order.pages}\n'
    order_info += f'Унікальність: {order.uniqueness}%\n'
    order_info += f'Дедлайн: {order.deadline}\n'
    order_info += f'Коментар: {order.comment}\n'
    order_info += f'Вартість: {order.cost} грн'
    return order_info

# Функція для обробки команди /start
def start(update, context):
    context.bot.send_message(chat_id=update.effective_chat.id, text='Вітаю! Я можу допомогти Вам замовити роботу. Якщо у Вас є питання щодо мого використання, введіть /help.')

# Функція для обробки команди /help
def help(update, context):
    help_text = 'Для замовлення роботи виконайте наступні кроки:\n'
    help_text += '1. Відкрийте діалог з ботом, натиснувши кнопку "Start"\n'
    help_text += '2. Виконайте команду /order\n'
    help_text += '3. Слідуйте інструкціям бота та введіть всі необхідні дані\n'
    help_text += '4. Очікуйте на відповідь від оператора замовлення\n\n'
    help_text += 'Якщо у вас виникли додаткові запитання або проблеми з ботом, виконайте команду /support'
    update.message.reply_text(help_text)

# Функція для обробки команди /support
def support(update, context):
    support_text = 'Якщо у вас виникли проблеми з ботом або вам потрібна допомога, зверніться до нашої служби підтримки:\n'
    support_text += 'Телефон: +380123456789\n'
    support_text += 'Email: support@company.com\n'
    update.message.reply_text(support_text)

# Функція для обробки команди /order
def order(update, context):
order_text = 'Для замовлення роботи введіть наступні дані:\n'
order_text += '1. Назва роботи\n'
order_text += '2. Термін виконання\n'
order_text += '3. Опис роботи\n'
order_text += '4. Контактна інформація\n\n'
order_text += 'Приклад: "Розробка сайту, термін - 2 тижні, опис - створення сайту для онлайн-магазину, контакт - email@example.com"\n'
update.message.reply_text(order_text)

# Функція для обробки повідомлень користувачів
def message_handler(update, context):
    text = update.message.text.lower()
    if text == '/help':
        help_command(update, context)
    elif text == '/support':
        support(update, context)
    elif text == '/order':
        order(update, context)
    else:
        unknown_text = 'Вибачте, я не розумію вашого запиту. Використайте команду /help для отримання додаткової інформації'
        update.message.reply_text(unknown_text)

# Функція для запуску бота
def main():
    updater = Updater("6201719090:AAHVmrXtpwRTD31h2XZtvF29S8sVr2VTOj8", use_context=True)
    dp = updater.dispatcher
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(MessageHandler(Filters.text, message_handler))
    updater.start_polling()
    updater.idle()

# Функція для обробки команди /start
def start(update, context):
    start_text = 'Вітаю! Я - бот для замовлення робіт. Для отримання довідки використовуйте команду /help.'
    update.message.reply_text(start_text)

# Функція для обробки команди /help
def help_command(update, context):
    help_text = 'Цей бот допоможе вам замовити роботу. Ви можете скористатись наступними командами:\n\n'
    help_text += '1. Використовуйте команду /order для замовлення роботи.\n'
    help_text += '2. Використовуйте команду /status, щоб перевірити статус виконання роботи.\n'
    help_text += '3. Використовуйте команду /cancel, щоб скасувати замовлення роботи.\n'
    help_text += '4. Використовуйте команду /feedback, щоб залишити відгук про роботу.\n'
    help_text += '5. Якщо виникли будь-які проблеми, зверніться до адміністратора боту.\n\n'
    help_text += 'Список доступних команд:\n'
    help_text += '/start - почати роботу з ботом\n'
    help_text += '/help - довідка та інструкці


# Функція для запуску бота
def main():
    updater = Updater("6201719090:AAHVmrXtpwRTD31h2XZtvF29S8sVr2VTOj8", use_context=True)
    dp = updater.dispatcher
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(MessageHandler(Filters.text, message_handler))
    updater.start_polling()
    updater.idle()

    if __name__ == '__main__':
        main()

return

if __name__ == '__main__':
    TOKEN = '6201719090:AAHVmrXtpwRTD31h2XZtvF29S8sVr2VTOj8", use_context=True'
    updater = Updater(TOKEN, use_context=True)

    # Додаємо обробники команд
    updater.dispatcher.add_handler(CommandHandler('help', help))
    updater.dispatcher.add_handler(CommandHandler('start', start))

    # Запускаємо бота
    updater.start_polling()
    updater.idle()


# Зупиняємо бота при натисканні Ctrl + C
updater.idle()
help_text += '4. Якщо виникли будь-які проблеми, зверніться до адміністратора боту.\n\n'
help_text += 'Список доступних команд:\n'
help_text += '/start - почати роботу з ботом\n'
help_text += '/help - довідка та інструкції щодо використання боту\n'
help_text += '/order - замовити роботу\n'
help_text += '/status - перевірити статус виконання роботи\n'
help_text += '/cancel - скасувати замовлення роботи\n'
help_text += '/feedback - залишити відгук про роботу\n'
update.message.reply_text(help_text)

# Функція для обробки команди /order
def order(update, context):
update.message.reply_text('Для замовлення роботи будь ласка, опишіть її деталі відповідно до наступного шаблону:\n\n'
'Тема роботи: \n'
'Тип роботи (курсова, дипломна, реферат тощо): \n'
'Обсяг роботи (у сторінках): \n'
'Термін виконання (у днях): \n'
'Додаткові вимоги та коментарі: \n\n'
'Приклад заповнення:\n'
'Тема роботи: Особливості застосування нейронних мереж для обробки зображень\n'
'Тип роботи: Курсова\n'
'Обсяг роботи: 20\n'
'Термін виконання: 14\n'
'Додаткові вимоги та коментарі: Зверніть особливу увагу на розділ про зображення з високою роздільною здатністю\n'
'Команда для відправки заповненої форми: /submit')

# Функція для обробки команди /submit
def submit(update, context):
user_data = context.user_data['order_data']
if user_data['topic'] is not None and user_data['type'] is not None and user_data['pages'] is not None and user_data['deadline'] is not None:
# відправляємо замовлення адміністратору боту
admin_chat_id = "ваш id чату з адміністратором боту"
order_text = f'Нове замовлення від користувача {update.message.chat_id}:\n\n'
order_text += f'Тема роботи: {user_data["topic"]}\n'
order_text += f'Тип роботи: {user_data["type"]}\n'
order_text += f'Обсяг роботи: {user_data["pages"]} сторінок\n'
order_text += f'Термін виконання: {user_data["deadline"]} днів\n'
order_text += f'Додаткові вимоги та коментарі: {user_data["comments"]}'
context.bot.send_message(chat_id=admin_chat_id, text=order_text)
update.message.reply_text('Ваше замовлення надіслано адміністратору боту. Ви отримаєте повідомлення про підтвердження замовлення.')
else:
update.message.reply_text('Не всі поля форми заповнені. Будь ласка, заповніть форму повністю.')

# Функція для обробки команди /status
def status(update, context):
update.message.reply_text('Статус вашого замовлення: Виконується/Очікує підтвердження/Скасовано')

# Функція для обробки команди /cancel
def cancel(update, context):
update.message.reply_text('Ваше замовлення скасовано.')

# Функція для обробки команди /feedback
def feedback(update, context):
update.message.reply_text('Для залишення відгуку напишіть повідомлення.')

# Функція для обробки повідомлення з відгуком
def receive_feedback(update, context):
feedback_text = update.message.text
admin_chat_id = "ваш id чату з адміністратором боту"
feedback_message = f'Відгук від користувача {update.message.chat_id}: {feedback_text}'
context.bot.send_message(chat_id=admin_chat_id, text=feedback_message)
update.message.reply_text('Дякуємо за ваш відгук!')
def start(update, context):
    user_name = update.message.chat.first_name
    welcome_message = f'Привіт, {user_name}! Я - бот для замовлення написання студентських робіт.\n'
    welcome_message += 'Якщо ви хочете зробити замовлення, скористайтеся командою /order.\n'
    welcome_message += 'Якщо ви хочете залишити відгук, скористайтеся командою /feedback.\n'
    welcome_message += 'Якщо ви хочете перевірити статус свого замовлення, скористайтеся командою /status.\n'
    welcome_message += 'Якщо ви хочете скасувати своє замовлення, скористайтеся командою /cancel.'
    update.message.reply_text(welcome_message)
def order(update, context):
    context.user_data['order_data'] = {'topic': None, 'type': None, 'pages': None, 'deadline': None, 'comments': None}
    update.message.reply_text('Давайте розпочнемо процес замовлення. Якщо ви хочете скасувати замовлення, скористайтеся командою /cancel.\n\nВведіть тему вашої роботи:')
    return 'topic'
def process_order_input(update, context):
    user_data = context.user_data['order_data']
    text = update.message.text

    if 'topic' in context.user_data:
        user_data['topic'] = text
        update.message.reply_text('Введіть тип вашої роботи (наприклад, курсова, дипломна, реферат і т.д.):')
        return 'type'

    if 'type' in context.user_data:
        user_data
def help(update, context):
    help_message = 'Список команд: \n'
    help_message += '/submit - надіслати замовлення\n'
    help_message += '/status - перевірити статус замовлення\n'
    help_message += '/cancel - скасувати замовлення\n'
    help_message += '/feedback - залишити відгук\n'
    help_message += '/help - список доступних команд\n'
    update.message.reply_text(help_message)
def start(update, context):
    start_message = 'Вітаємо у нашому боті!\n'
    start_message += 'Для оформлення замовлення використовуйте команду /submit\n'
    start_message += 'Щоб переглянути список команд, скористайтеся командою /help'
    update.message.reply_text(start_message)
def about(update, context):
    about_message = 'Це бот для замовлення наукових робіт.\n'
    about_message += 'Бот розроблений для студентів, які не мають часу або можливості самостійно написати наукову роботу.\n'
    about_message += 'Для оформлення замовлення використовуйте команду /submit\n'
    about_message += 'Щоб переглянути список команд, скористайтеся командою /help'
    update.message.reply_text(about_message)
def order_confirmation(chat_id):
    confirmation_text = 'Ваше замовлення прийнято на обробку. Очікуйте повідомлення про підтвердження замовлення.'
    context.bot.send_message(chat_id=chat_id, text=confirmation_text)
import sqlite3

def init_db():
    conn = sqlite3.connect('orders.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS orders
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                 user_id INTEGER,
                 topic TEXT,
                 type TEXT,
                 pages INTEGER,
                 deadline INTEGER,
                 comments TEXT,
                 status TEXT DEFAULT 'pending')''')
    conn.commit()
    conn.close()
def add_order(user_id, topic, type, pages, deadline, comments):
    conn = sqlite3.connect('orders.db')
    c = conn.cursor()
    c.execute("INSERT INTO orders (user_id, topic, type, pages, deadline, comments) VALUES (?, ?, ?, ?, ?, ?)",
              (user_id, topic, type, pages, deadline, comments))
    order_id = c.lastrowid
    conn.commit()
    conn.close()
    return order_id
def get_orders(user_id):
    conn = sqlite3.connect('orders.db')
    c = conn.cursor()
    c.execute("SELECT * FROM orders WHERE user_id=?", (user_id,))
    orders = c.fetchall()
    conn.close()
    return orders
# Функція для обробки команди /orders, яка буде виводити список замовлень для адміністратора боту
def orders(update, context):

# перевіряємо, чи користувач з правильними правами
admin_chat_id = "ваш id чату з адміністратором боту"
if update.message.chat_id == admin_chat_id:
# отримуємо список всіх замовлень, які є у нас в базі даних
orders_list = db.get_all_orders()
if orders_list:
# якщо є замовлення, виводимо їх у вигляді таблиці
orders_table = 'Список замовлень:\n\n'
orders_table += 'ID | Користувач | Тема роботи | Тип роботи | Обсяг роботи | Термін виконання | Статус\n'
orders_table += '-- | ---------- | ----------- | ---------- | ------------ | ---------------- | ------\n'
for order in orders_list:
orders_table += f'{order["id"]} | {order["user_id"]} | {order["topic"]} | {order["type"]} | {order["pages"]} | {order["deadline"]} | {order["status"]}\n'
context.bot.send_message(chat_id=admin_chat_id, text=orders_table)
else:
context.bot.send_message(chat_id=admin_chat_id, text='Замовлень немає.')
else:
update.message.reply_text('Ви не маєте прав доступу до цієї команди.')

# Функція для обробки команди /setstatus, яка буде змінювати статус замовлення
def set_status(update, context):

# перевіряємо, чи користувач з правильними правами
admin_chat_id = "ваш id чату з адміністратором боту"
if update.message.chat_id == admin_chat_id:
# отримуємо параметри команди
args = context.args
if len(args) == 2:
order_id = args[0]
new_status = args[1]
# змінюємо статус замовлення
success = db.set_order_status(order_id, new_status)
if success:
context.bot.send_message(chat_id=admin_chat_id, text=f'Статус замовлення {order_id} успішно змінено на {new_status}.')
else:
context.bot.send_message(chat_id=admin_chat_id, text=f'Помилка при зміні статусу замовлення {order_id}.')
else:
context.bot.send_message(chat_id=admin_chat_id
# Функція для обробки команди /orders
def orders(update, context):

# перевірка чи користувач є адміністратором боту
if update.message.chat_id != "ваш id чату з адміністратором боту":
update.message.reply_text('Ця команда доступна тільки адміністратору боту.')
return
orders = context.bot_data.get('orders', {})
if not orders:
update.message.reply_text('На даний момент немає замовлень.')
else:
orders_text = 'Список замовлень:\n\n'
for order_id, order_data in orders.items():
orders_text += f'ID замовлення: {order_id}\n'
orders_text += f'Користувач: {order_data["user_id"]}\n'
orders_text += f'Тема роботи: {order_data["topic"]}\n'
orders_text += f'Тип роботи: {order_data["type"]}\n'
orders_text += f'Обсяг роботи: {order_data["pages"]} сторінок\n'
orders_text += f'Термін виконання: {order_data["deadline"]} днів\n'
orders_text += f'Додаткові вимоги та коментарі: {order_data["comments"]}\n'
orders_text += f'Статус: {order_data["status"]}\n\n'
update.message.reply_text(orders_text)

# Функція для обробки команди /confirm_order
def confirm_order(update, context):

# перевірка чи користувач є адміністратором боту
if update.message.chat_id != "ваш id чату з адміністратором боту":
update.message.reply_text('Ця команда доступна тільки адміністратору боту.')
return
order_id = context.args[0]
orders = context.bot_data.get('orders', {})
if order_id not in orders:
update.message.reply_text('Замовлення з таким ID не існує.')
return
orders[order_id]['status'] = 'Виконано'
admin_chat_id = "ваш id чату з адміністратором боту"
context.bot.send_message(chat_id=admin_chat_id, text=f'Замовлення {order_id} виконано.')

# збереження змінених даних
context.bot_data['orders'] = orders
def help_command(update, context):
    """Send a message when the command /help is issued."""
    help_text = "Список доступних команд:\n\n"
    help_text += "/start - почати діалог з ботом\n"
    help_text += "/submit - надіслати замовлення\n"
    help_text += "/status - перевірити статус замовлення\n"
    help_text += "/cancel - скасувати замовлення\n"
    help_text += "/feedback - залишити відгук про бота\n"
    help_text += "/help - отримати довідку про доступні команди\n"
    help_text += "\nЩоб надіслати замовлення, заповніть форму, яку відправить бот.\n"
    help_text += "Після заповнення форми натисніть /submit.\n"
    help_text += "Щоб скасувати замовлення, натисніть /cancel.\n"
    help_text += "Щоб перевірити статус замовлення, натисніть /status.\n"
    help_text += "Щоб залишити відгук, натисніть /feedback та надішліть повідомлення.\n"
    update.message.reply_text(help_text)
def start(update, context):
    user_name = update.message.chat.first_name
    welcome_message = f"Привіт, {user_name}! Я бот для замовлення студентських робіт. Я можу надіслати тобі форму для замовлення, дати інформацію про статус замовлення та отримати відгук. Ось список доступних команд:\n\n"
    welcome_message += "/order - замовити роботу\n"
    welcome_message += "/status - перевірити статус замовлення\n"
    welcome_message += "/feedback - залишити відгук\n"
    update.message.reply_text(welcome_message)
def help(update, context):
    help_message = "Ось список доступних команд:\n\n"
    help_message += "/order - замовити роботу\n"
    help_message += "/status - перевірити статус замовлення\n"
    help_message += "/feedback - залишити відгук\n"
    help_message += "/help - додаткова допомога\n"
    update.message.reply_text(help_message)
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove
import logging

# налаштування логування
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# функція для обробки команди /start
def start(update, context):
    update.message.reply_text('Вітаю! Я бот для замовлення студентських робіт. Щоб зробити замовлення, скористайтесь командою /order')

# функція для обробки команди /order
def order(update, context):
    # відправляємо повідомлення з привітанням
    update.message.reply_text('Щоб зробити замовлення, заповніть форму:')

    # відправляємо запит на тему роботи
    update.message.reply_text('Введіть тему вашої роботи:')

    # зберігаємо стан конверсації
    context.user_data['state'] = 'topic'

# функція для обробки теми роботи
def receive_topic(update, context):
    # зберігаємо тему роботи в контексті користувача
    context.user_data['order_data'] = {'topic': update.message.text}

    # відправляємо запит на тип роботи
    reply_keyboard = [['Курсова робота', 'Дипломна робота'], ['Реферат', 'Інше']]
    update.message.reply_text('Виберіть тип роботи:', reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True))

    # зберігаємо стан конверсації
    context.user_data['state'] = 'type'

# функція для обробки типу роботи
def receive_type(update, context):
    # зберігаємо тип роботи в контексті користувача
    context.user_data['order_data']['type'] = update.message.text

    # відправляємо запит на обсяг роботи
    update.message.reply_text('Введіть обсяг роботи (кількість сторінок):')

    # зберігаємо стан конверсації
    context.user_data['state'] = 'pages'

# функція для обробки обсягу роботи
def receive_pages(update, context):
    # зберігаємо обсяг роботи в контексті користувача
    context.user_data['order_data']['pages'] = update
# Функція для обробки команди /help
def help(update, context):
help_text = "Список команд:\n\n"
help_text += "/start - Початок роботи з ботом\n"
help_text += "/submit - Оформити замовлення\n"
help_text += "/status - Перевірити статус замовлення\n"
help_text += "/cancel - Скасувати замовлення\n"
help_text += "/feedback - Залишити відгук\n"
help_text += "/help - Показати цей список команд"
update.message.reply_text(help_text)

# Функція для обробки невідомих команд
def unknown(update, context):
update.message.reply_text("Вибачте, я не розумію цю команду. Використовуйте /help, щоб переглянути список доступних команд.")

# Функція для обробки помилкових викликів
def error(update, context):
logger.warning('Update "%s" caused error "%s"', update, context.error)

# Функція для обробки повідомлень з картинками
def handle_images(update, context):
# перевіряємо чи є фото у повідомленні
if update.message.photo:
# отримуємо найбільше за розміром фото
photo_file = update.message.photo[-1].get_file()
# зберігаємо фото в папку images
photo_file.download('images/' + photo_file.file_path.rsplit('/', 1)[-1])
update.message.reply_text('Фото збережено.')
else:
update.message.reply_text('Вибачте, ви надіслали не фото.')

# додаємо функції до диспетчера
dispatcher.add_handler(CommandHandler('help', help))
dispatcher.add_handler(MessageHandler(Filters.command, unknown))
dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, echo))
dispatcher.add_handler(MessageHandler(Filters.photo, handle_images))
dispatcher.add_error_handler(error)
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, ConversationHandler
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove

# стани розмови
TOPIC, TYPE, PAGES, DEADLINE, COMMENTS, CONFIRMATION = range(6)

# клавіатура для вибору типу роботи
type_keyboard = [['Курсова робота', 'Дипломна робота'], ['Реферат', 'Інше']]
type_markup = ReplyKeyboardMarkup(type_keyboard, one_time_keyboard=True)

# клавіатура для підтвердження замовлення
confirmation_keyboard = [['Так', 'Ні']]
confirmation_markup = ReplyKeyboardMarkup(confirmation_keyboard, one_time_keyboard=True)

# функція для обробки команди /start
def start(update, context):
    update.message.reply_text('Вітаємо вас в нашому боті! Щоб зробити замовлення, введіть /submit')
    
# функція для обробки команди /submit
def submit(update, context):
    update.message.reply_text('Введіть тему роботи:')
    return TOPIC

# функція для отримання теми роботи від користувача
def get_topic(update, context):
    user_data = context.user_data
    user_data['order_data'] = {}
    user_data['order_data']['topic'] = update.message.text
    update.message.reply_text('Оберіть тип роботи:', reply_markup=type_markup)
    return TYPE

# функція для отримання типу роботи від користувача
def get_type(update, context):
    user_data = context.user_data
    user_data['order_data']['type'] = update.message.text
    update.message.reply_text('Введіть обсяг роботи в сторінках:')
    return PAGES

# функція для отримання обсягу роботи від користувача
def get_pages(update, context):
    user_data = context.user_data
    user_data['order_data']['pages'] = update.message.text
    update.message.reply_text('Введіть термін виконання роботи в днях:')
    return DEADLINE

# функція для отримання терміну виконання роботи від користувача
def get_deadline(update, context):
    user_data = context.user_data
    user_data['order_data']['deadline'] = update.message.text
    update.message.reply_text('Введіть додаткові вимоги та коментарі:')
    return COMMENTS

# функція для отримання додаткових вимог та коментарів від користувача
def get_comments(update, context):
    user_data = context.user_data
    user_data['order_data']['comments'] = update.message.text
    order_text = f'Ви збираєтесь зр
обити замовлення з наступними параметрами:\n\n'
order_text += f'Тема роботи: {user_data["order_data"]["topic"]}\n'
order_text += f'Тип роботи: {user_data["order_data"]["type"]}\n'
order_text += f'Обсяг роботи: {user_data["order_data"]["pages"]} сторінок\n'
order_text += f'Термін виконання: {user_data["order_data"]["deadline"]} днів\n'
order_text += f'Додаткові вимоги та коментарі: {user_data["order_data"]["comments"]}\n\n'
order_text += 'Будь ласка, перевірте правильність введених даних. Якщо всі дані вірні, введіть команду /submit для підтвердження замовлення, якщо ж є помилки, скористайтеся командою /edit для внесення змін.'
update.message.reply_text(order_text)
# функція для отримання додаткових вимог та коментарів від користувача
def get_comments(update, context):
user_data = context.user_data
user_data['order_data']['comments'] = update.message.text
order_text = f'Ви збираєтесь зробити замовлення з наступними параметрами:\n\n'
order_text += f'Тема роботи: {user_data["order_data"]["topic"]}\n'
order_text += f'Тип роботи: {user_data["order_data"]["type"]}\n'
order_text += f'Обсяг роботи: {user_data["order_data"]["pages"]} сторінок\n'
order_text += f'Термін виконання: {user_data["order_data"]["deadline"]} днів\n'
order_text += f'Додаткові вимоги та коментарі: {user_data["order_data"]["comments"]}\n\n'
order_text += 'Чи правильно відображаються всі параметри вашого замовлення? (так/ні)'
update.message.reply_text(order_text)
return 'CONFIRM_ORDER'

# функція для підтвердження замовлення користувачем
def confirm_order(update, context):
user_input = update.message.text.lower()
if user_input == 'так':
# відправляємо повідомлення користувачу про те, що замовлення прийнято
update.message.reply_text('Ваше замовлення прийнято. Ви отримаєте повідомлення про його статус.')
# відправляємо замовлення адміністратору боту
admin_chat_id = "ваш id чату з адміністратором боту"
order_text = f'Нове замовлення від користувача {update.message.chat_id}:\n\n'
order_text += f'Тема роботи: {context.user_data["order_data"]["topic"]}\n'
order_text += f'Тип роботи: {context.user_data["order_data"]["type"]}\n'
order_text += f'Обсяг роботи: {context.user_data["order_data"]["pages"]} сторінок\n'
order_text += f'Термін виконання: {context.user_data["order_data"]["deadline"]} днів\n'
order_text += f'Додаткові вимоги та коментарі: {context.user_data["order_data"]["comments"]}'
context.bot.send_message(chat_id=admin_chat_id, text=order_text)
# очищуємо дані користувача
context.user_data.clear()
return ConversationHandler.END
elif user_input == 'ні':
# перенаправляємо користувача до функції для заповнення даних ще раз
update.message.reply_text('Будь ласка, введіть тему вашої роботи.')
return TOPIC
else:
# користувач ввів щось неправильне
update.message.reply_text('Будь ласка, введіть "так" або "ні".')
return CONFIRM_ORDER
# функція для перенаправлення користувача до функції для заповнення даних
def restart_order(update, context):
    user_data = context.user_data
    user_data['order_data'] = {}
    update.message.reply_text('Вибачте, щось пішло не так. Будь ласка, заповніть форму замовлення повністю.')
    return get_topic(update, context)
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            GET_TOPIC: [MessageHandler(Filters.text, get_topic)],
            GET_TYPE: [MessageHandler(Filters.text, get_type)],
            GET_PAGES: [MessageHandler(Filters.text, get_pages)],
            GET_DEADLINE: [MessageHandler(Filters.text, get_deadline)],
            GET_COMMENTS: [MessageHandler(Filters.text, get_comments)],
            CONFIRM_ORDER: [MessageHandler(Filters.regex('^так$'), submit),
                            MessageHandler(Filters.regex('^ні$'), restart_order)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
# імпортуємо необхідні класи та функції з бібліотеки telegram.ext
from telegram.ext import Updater, CommandHandler, ConversationHandler, MessageHandler, Filters

# створюємо функцію для початку діалогу
def start(update, context):
    update.message.reply_text('Вітаємо в нашому боті замовлення курсових робіт. Для початку роботи скористайтеся командою /order.')

# функція для обробки команди /order
def order(update, context):
    update.message.reply_text('Давайте розпочнемо оформлення замовлення. Введіть тему курсової роботи.')
    # зберігаємо дані користувача в об'єкті user_data з використанням змінної-контейнера для темпорарних даних
    context.user_data['order_data'] = {}
    return 'get_topic'

# функція для отримання теми курсової роботи
def get_topic(update, context):
    user_data = context.user_data
    user_data['order_data']['topic'] = update.message.text
    update.message.reply_text('Введіть тип курсової роботи.')
    return 'get_type'

# функція для отримання типу курсової роботи
def get_type(update, context):
    user_data = context.user_data
    user_data['order_data']['type'] = update.message.text
    update.message.reply_text('Введіть обсяг курсової роботи в сторінках.')
    return 'get_pages'

# функція для отримання обсягу курсової роботи
def get_pages(update, context):
    user_data = context.user_data
    pages = update.message.text
    # перевіряємо, що введені дані є числом
    if pages.isdigit():
        user_data['order_data']['pages'] = int(pages)
        update.message.reply_text('Введіть термін виконання роботи в днях.')
        return 'get_deadline'
    else:
        update.message.reply_text('Будь ласка, введіть числове значення.')
        return 'get_pages'

# функція для отримання терміну виконання курсової роботи
def get_deadline(update, context):
user_data = context.user_data
deadline = update.message.text
# перевіряємо, що введені дані є числом
if deadline.isdigit():
user_data['order_data']['deadline'] = int(deadline)
update.message.reply_text('Введіть додаткові вимоги та коментарі щодо курсової роботи:')
return COMMENTS
else:
update.message.reply_text('Будь ласка, введіть число.')
return DEADLINE

# функція для отримання додаткових вимог та коментарів від користувача
def get_comments(update, context):
user_data = context.user_data
user_data['order_data']['comments'] = update.message.text
order_text = f'Ви збираєтесь замовити курсову роботу на тему "{user_data["order_data"]["topic"]}", '
order_text += f'обсягом {user_data["order_data"]["length"]} сторінок, з терміном виконання {user_data["order_data"]["deadline"]} днів, '
order_text += f'з додатковими вимогами та коментарями: {user_data["order_data"]["comments"]}.'
update.message.reply_text(order_text)
return confirm_order(update, context)

# функція для підтвердження замовлення та відправлення даних у чат-бота для обробки
def confirm_order(update, context):
user_data = context.user_data
order_data = user_data['order_data']
order_text = f'Ви збираєтесь замовити курсову роботу на тему "{order_data["topic"]}", '
order_text += f'обсягом {order_data["length"]} сторінок, з терміном виконання {order_data["deadline"]} днів, '
order_text += f'з додатковими вимогами та коментарями: {order_data["comments"]}.'
update.message.reply_text(order_text)
update.message.reply_text('Введіть ваше ім'я:')
return CUSTOMER_NAME
# функція для отримання імені клієнта
def get_customer_name(update, context):
user_data = context.user_data
user_data['order_data']['customer_name'] = update.message.text
update.message.reply_text('Введіть ваш номер телефону:')
return CUSTOMER_PHONE

# функція для отримання номера телефону клієнта
def get_customer_phone(update, context):
    user_data = context.user_data
    user_data['order_data']['customer_phone'] = update.message.contact.phone_number
    order_data = user_data['order_data']
    order_text = f'Нове замовлення:\n'
    for key, value in order_data.items():
        order_text += f'{key}: {value}\n'
    update.message.reply_text(f'Дякуємо, ваш номер телефону було збережено. \n{order_text}')
    return ConversationHandler.END
# функція для отримання email клієнта
def get_customer_email(update, context):
user_data = context.user_data
user_data['order_data']['customer_email'] = update.message.text
order_data = user_data['order_data']
order_text = f'Нове замовлення:\n'
for key, value in order_data.items():
order_text += f'{key}: {value}\n'
# відправляємо замовлення адміністратору
context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=order_text)
# відправляємо підтвердження користувачу
update.message.reply_text('Дякуємо! Ваше замовлення прийнято до обробки.')
return ConversationHandler.END

# функція для відміни замовлення
def cancel_order(update, context):
update.message.reply_text('Замовлення скасовано.')
return ConversationHandler.END

# функція для обробки помилкових вхідних даних
def invalid_input(update, context):
update.message.reply_text('Введені дані некоректні. Спробуйте ще раз.')
return

def main():
# створюємо екземпляр класу Updater та передаємо йому токен бота
updater = Updater(TOKEN, use_context=True)
# створюємо екземпляр класу Dispatcher
dp = updater.dispatcher
# створюємо обєкт класу ConversationHandler для обробки діалогу з користувачем
conv_handler = ConversationHandler(
    # визначаємо список функцій-зразків, які будуть відповідати за кожен стан діалогу
    entry_points=[CommandHandler('start', start)],
    states={
        CHOOSING: [MessageHandler(Filters.regex('^(Курсова робота)$'), choose_service)],
        TYPING: [MessageHandler(Filters.text & ~Filters.command, get_service_type)],
        DEADLINE: [MessageHandler(Filters.text & ~Filters.command, get_deadline)],
        PHONE: [MessageHandler(Filters.text & ~Filters.command, get_customer_phone)],
        EMAIL: [MessageHandler(Filters.text & ~Filters.command, get_customer_email)],
        COMMENTS: [MessageHandler(Filters.text & ~Filters.command, get_comments)],
    },
    fallbacks=[CommandHandler('cancel', cancel_order)]
)

# створюємо обєкт класу ConversationHandler для обробки діалогу з користувачем
conv_handler = ConversationHandler(
    # визначаємо список функцій-зразків, які будуть відповідати за кожен стан діалогу
    entry_points=[CommandHandler('start', start)],
    states={
        CHOOSING: [MessageHandler(Filters.regex('^(Курсова робота)$'), choose_service)],
        TYPING: [MessageHandler(Filters.text & ~Filters.command, get_service_type)],
        DEADLINE: [MessageHandler(Filters.text & ~Filters.command, get_deadline)],
        PHONE: [MessageHandler(Filters.text & ~Filters.command, get_customer_phone)],
        EMAIL: [MessageHandler(Filters.text & ~Filters.command, get_customer_email)],
        COMMENTS: [MessageHandler(Filters.text & ~Filters.command, get_comments)],
    },
    fallbacks=[CommandHandler('cancel', cancel_order)]
)

# додаємо об'єкт класу ConversationHandler до об'єкту класу Dispatcher
dp.add_handler(conv_handler)

# додаємо функцію для обробки помилкових вхідних даних
dp.add_handler(MessageHandler(Filters.text & ~Filters.command, invalid_input))

# запускаємо бота
updater.start_polling()
# запускаємо процес отримання оновлень з Telegram
updater.idle()
імпортуємо бібліотеки
import os
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
import psycopg2

# отримуємо дані для підключення до бази даних зі змінних середовища Heroku
DATABASE_URL = os.environ['DATABASE_URL']

# створюємо об'єкт для підключення до бази даних
engine = create_engine(DATABASE_URL)

# створюємо сесію для роботи з базою даних
Session = sessionmaker(bind=engine)
session = Session()

# створюємо клас-модель для таблиці замовлень
Base = declarative_base()
class Order(Base):
tablename = 'orders'

id = Column(Integer, primary_key=True)
service_type = Column(String)
deadline = Column(Integer)
customer_name = Column(String)
customer_phone = Column(String)
customer_email = Column(String)
comments = Column(String)

def __repr__(self):
    return f"<Order(service_type='{self.service_type}', deadline={self.deadline}, customer_name='{self.customer_name}', customer_phone='{self.customer_phone}', customer_email='{self.customer_email}', comments='{self.comments}')>"
створюємо таблицю замовлень у базі даних, якщо її ще не існує
Base.metadata.create_all(engine)

# функція для збереження замовлення у базі даних
def save_order(order_data):
# створюємо об'єкт класу Order з даними про замовлення
order = Order(service_type=order_data['service_type'],
deadline=order_data['deadline'],
customer_name=order_data['customer_name'],
customer_phone=order_data['customer_phone'],
customer_email=order_data['customer_email'],
comments=order_data['comments'])
імпортуємо бібліотеки
import os
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
import psycopg2

# отримуємо дані для підключення до бази даних зі змінних середовища Heroku
DATABASE_URL = os.environ['postgres://yqluyjjwqokfic:668a8e54a7943f0ebca500165b3aa9d9786df25ab6c31eb041e871475d3e53aa@ec2-52-48-159-67.eu-west-1.compute.amazonaws.com:5432/d7lr098nlc0jn6L']

#створюємо об'єкт для підключення до бази даних
engine = create_engine(DATABASE_URL)

#створюємо сесію для роботи з базою даних
Session = sessionmaker(bind=engine)
session = Session()

#створюємо клас-модель для таблиці замовлень
Base = declarative_base()
class Order(Base):
tablename = 'orders'

id = Column(Integer, primary_key=True)
service_type = Column(String)
deadline = Column(Integer)
customer_name = Column(String)
customer_phone = Column(String)
customer_email = Column(String)
comments = Column(String)

def __repr__(self):
    return f"<Order(service_type='{self.service_type}', deadline={self.deadline}, customer_name='{self.customer_name}', customer_phone='{self.customer_phone}', customer_email='{self.customer_email}', comments='{self.comments}')>"
# створюємо таблицю замовлень у базі даних, якщо її ще не існує
Base.metadata.create_all(engine)

# функція для збереження замовлення у базі даних
def save_order(order_data):
# створюємо об'єкт класу Order з даними про замовлення
order = Order(service_type=order_data['service_type'],
deadline=order_data['deadline'],
customer_name=order_data['customer_name'],
customer_phone=order_data['customer_phone'],
customer_email=order_data['customer_email'],
comments=order_data['comments'])
# додаємо замовлення до бази даних
session.add(order)
session.commit()
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base, Order

DATABASE_URL = os.environ['DATABASE_URL']

engine = create_engine(DATABASE_URL, echo=True)

# створюємо клас-модель для таблиці замовлень
class Order(Base):
tablename = 'orders'
id = Column(Integer, primary_key=True)
service_type = Column(String)
deadline = Column(Integer)
customer_name = Column(String)
customer_phone = Column(String)
customer_email = Column(String)
comments = Column(String)

def __repr__(self):
    return f"<Order(service_type='{self.service_type}', deadline={self.deadline}, customer_name='{self.customer_name}', customer_phone='{self.customer_phone}', customer_email='{self.customer_email}', comments='{self.comments}')>"
створюємо таблицю замовлень у базі даних
Base.metadata.create_all(engine)

# функція для збереження замовлення у базі даних
def save_order(order_data):
# створюємо об'єкт класу Order з даними про замовлення
order = Order(
service_type=order_data['service_type'],
deadline=order_data['deadline'],
customer_name=order_data['customer_name'],
customer_phone=order_data['customer_phone'],
customer_email=order_data['customer_email'],
comments=order_data['comments']
)# відкриваємо сесію для взаємодії з базою даних
Session = sessionmaker(bind=engine)
session = Session()

# додаємо замовлення до бази даних
session.add(order)
session.commit()

# закриваємо сесію
session.close()
# створюємо функцію для відправлення повідомлення з деталями замовлення
def send_order_details(order_data, chat_id):
message = f"Ваше замовлення:\n\n"
message += f"Тип послуги: {order_data['service_type']}\n"
message += f"Термін виконання: {order_data['deadline']} днів\n"
message += f"Ім'я клієнта: {order_data['customer_name']}\n"
message += f"Номер телефону: {order_data['customer_phone']}\n"
message += f"Email: {order_data['customer_email']}\n"
message += f"Коментарі: {order_data['comments']}\n\n"
message += f"Дякуємо за замовлення!"
bot.send_message(chat_id=chat_id, text=message)
# створюємо функцію для обробки отриманих відповідей від користувача
def handle_user_response(update, context):
# отримуємо об'єкт класу CallbackQuery з відповіддю користувача
query = update.callback_query
# отримуємо текст відповіді користувача
response = query.data

# отримуємо дані про замовлення з контексту
order_data = context.user_data['order_data']

# зберігаємо відповідь користувача в залежності від поточного стану діалогу
if order_data['state'] == CHOOSING:
    order_data['service_type'] = response
    query.edit_message_text(text=f"Ви обрали послугу \"{response}\". Надішліть термін виконання (у днях):")
    order_data['state'] = TYPING
elif order_data['state'] == TYPING:
    try:
        order_data['deadline'] = int(response)
        query.edit_message_text(text=f"Термін виконання: {response} днів. Надішліть Ваше ім'я:")
        order_data['state'] = DEADLINE
    except ValueError:
        query.edit_message_text(text="Невірний формат терміну виконання. Будь ласка, введіть ціле число.")
elif order_data['state'] == DEADLINE:
    order_data['customer_name'] = response
    query.edit_message_text(text=f"Ім'я: {response}. Надішліть номер телефону:")
    order_data['state'] = PHONE
elif order_data['state'] == PHONE:
    order_data['customer_phone'] = response
    query.edit_message_text(text=f"Номер телефону: {response}. Надішліть Email:")
    order_data['state'] = EMAIL
elif order_data['state'] == EMAIL:
# перевіряємо, чи відповідь користувача є коректним email
if validate_email(response):
order_data['customer_email'] = response
query.edit_message_text(text=f"Email: {response}. Надішліть коментар до замовлення (необов'язково):")
order_data['state'] = COMMENTS
else:
query.edit_message_text(text="Невірний формат Email. Будь ласка, введіть коректний Email.")
elif order_data['state'] == COMMENTS:
order_data['comments'] = response
# зберігаємо дані про замовлення у базу даних
save_order(order_data)
# відправляємо повідомлення з підтвердженням збереження замовлення
query.edit_message_text(text="Ваше замовлення успішно збережено! Дякуємо!")
# очищуємо дані про замовлення у контексті користувача
context.user_data.pop('order_data')
order_data['state'] = ConversationHandler.END

return order_data['state']
elif order_data['state'] == EMAIL:
# перевірка валідності email
if validate_email(response):
order_data['customer_email'] = response
query.edit_message_text(text=f"Email: {response}. Надішліть коментар (необов'язково):")
order_data['state'] = COMMENTS
else:
query.edit_message_text(text="Невірний формат Email. Будь ласка, введіть правильну адресу.")
elif order_data['state'] == COMMENTS:
order_data['comments'] = response
query.edit_message_text(text="Дякуємо за Ваше замовлення. Найближчим часом ми зв'яжемося з Вами.")
# зберігаємо замовлення у базу даних
save_order(order_data)
# очищуємо дані користувача з контексту
context.user_data.clear()
return ConversationHandler.END

# якщо виникла помилка в обробці відповіді користувача, виводимо повідомлення про помилку
else:
query.edit_message_text(text="Виникла помилка. Будь ласка, спробуйте ще раз.")
return order_data['state']

# повертаємо стан діалогу
return order_data['state']
elif order_data['state'] == EMAIL:
# перевіряємо, чи введений email коректний
if not re.match(r"[^@]+@[^@]+.[^@]+", response):
query.edit_message_text(text="Невірний формат email. Будь ласка, введіть коректний email.")
return EMAIL
order_data['customer_email'] = response
query.edit_message_text(text=f"Email: {response}. Надішліть коментар (опціонально):")
order_data['state'] = COMMENTS
elif order_data['state'] == COMMENTS:
order_data['comments'] = response
query.edit_message_text(text="Дякуємо за замовлення! Ми зв'яжемося з Вами найближчим часом.")
# зберігаємо замовлення у базу даних
save_order(order_data)
# очищаємо дані про замовлення з контексту
context.user_data.pop('order_data')
return ConversationHandler.END
# потрібно зберегти дані про замовлення у базі даних та повідомити користувача про успішне створення замовлення.
else:
order_data['customer_email'] = response
# створюємо об'єкт класу Order з даними про замовлення
order = Order(service_type=order_data['service_type'],
deadline=order_data['deadline'],
customer_name=order_data['customer_name'],
customer_phone=order_data['customer_phone'],
customer_email=order_data['customer_email'],
comments=order_data['comments'])
# зберігаємо замовлення у базі даних
try:
Session = sessionmaker(bind=engine)
session = Session()
session.add(order)
session.commit()
session.close()
query.edit_message_text(text="Ваше замовлення успішно створено! Ми зв'яжемось з вами найближчим часом.")
except:
query.edit_message_text(text="Виникла помилка при створенні замовлення. Будь ласка, спробуйте ще раз пізніше.")
# очищуємо дані про замовлення у контексті користувача
context.user_data['order_data'] = {'state': CHOOSING} Будь ласка, уточніть ваше замовлення та надішліть коментар (опціонально):")
order_data['state'] = COMMENTS
elif order_data['state'] == COMMENTS:
order_data['comments'] = response
query.edit_message_text(text=f"Дякуємо за ваше замовлення! Ми зв'яжемося з вами найближчим часом.")
# зберігаємо дані про замовлення у базі даних
save_order(order_data)
# очищуємо дані про замовлення з контексту
context.user_data['order_data'] = None
order_data['state'] = ConversationHandler.END
return order_data['state']

return CHOOSING

# функція для збереження замовлення у базі даних
def save_order(order_data):
    # створюємо об'єкт класу Order з даними про замовлення
    order = Order(service_type=order_data['service_type'], deadline=order_data['deadline'], customer_name=order_data['customer_name'], customer_phone=order_data['customer_phone'], customer_email=order_data['customer_email'], comments=order_data['comments'])

    # відкриваємо сесію з базою даних
    Session = sessionmaker(bind=engine)
    session = Session()

    # додаємо замовлення до бази даних
    session.add(order)
    session.commit()

    # закриваємо сесію
    session.close()

    # очищуємо дані змінної order_data
    order_data.clear()
    query.edit_message_text(text="Дякуємо за замовлення! Ми зв'яжемося з Вами найближчим часом.")
def start(update: Update, context: CallbackContext) -> None:
# """Починаємо діалог з користувачем та просимо вибрати послугу."""
# створюємо словник для зберігання даних про замовлення
order_data = {'state': CHOOSING}
context.user_data['order_data'] = order_data
# надсилаємо повідомлення з варіантами послуг
services = ['Консультація', 'Аудит', 'Рекламна кампанія', 'Створення сайту']
buttons = [InlineKeyboardButton(text=service, callback_data=service) for service in services]
keyboard = build_menu(buttons, n_cols=2)
reply_markup = InlineKeyboardMarkup(keyboard)
update.message.reply_text(
    "Виберіть послугу:",
    reply_markup=reply_markup
)
def handle_dialogue(update: Update, context: CallbackContext) -> None:
# """Обробляємо відповіді користувача та зберігаємо дані про замовлення."""
query = update.callback_query
if query:
# отримуємо текст відповіді користувача
response = query.data
    # отримуємо дані про замовлення з контексту
    order_data = context.user_data['order_data']

    # зберігаємо відповідь користувача в залежності від поточного стану діалогу
    if order_data['state'] == CHOOSING:
        order_data['service_type'] = response
        query.edit_message_text(text=f"Ви обрали послугу \"{response}\". Надішліть термін виконання (у днях):")
        order_data['state'] = TYPING
    elif order_data['state'] == TYPING:
        try:
            order_data['deadline'] = int(response)
            query.edit_message_text(text=f"Термін виконання: {response} днів. Надішліть Ваше ім'я:")
            order_data['state'] = DEADLINE
        except ValueError:
            query.edit_message_text(text="Невірний формат терміну виконання. Будь ласка, введіть ціле число.")
    elif order_data['state'] == DEADLINE:
        order_data['customer_name'] = response
        query.edit_message_text(text=f"Ім'я: {response}. Надішліть номер телефону:")
        order_data['state'] = PHONE
    elif order_data['state'] == PHONE:
        order_data['customer_phone'] = response
        query.edit_message_text(text=f"Номер телефону: {response}. Надішліть Email:")
        order_data['state'] = EMAIL
    elif order_data['state'] == EMAIL:
        if validate_email(response):
            order_data['customer _email'] = response
query.edit_message_text(text=f"Email: {response}. Надішліть коментар до замовлення:")
order_data['state'] = COMMENTS
else:
query.edit_message_text(text="Невірний формат Email. Будь ласка, введіть коректний Email.")
elif order_data['state'] == COMMENTS:
order_data['comments'] = response
query.edit_message_text(text=f"Коментар: {response}. Дякуємо за замовлення! Ми зв'яжемося з вами найближчим часом.")
order_data['state'] = ConversationHandler.END
# зберігаємо замовлення у базі даних
save_order(order_data)

# очищаємо дані користувача
context.user_data.clear()

return ConversationHandler.END
# зберігаємо email та коментарі користувача в залежності від поточного стану діалогу
elif order_data['state'] == EMAIL:
if validate_email(response):
order_data['customer_email'] = response
query.edit_message_text(text=f"Email: {response}. Надішліть коментарі до замовлення (необов'язково):")
order_data['state'] = COMMENTS
else:
query.edit_message_text(text="Невірний формат email. Будь ласка, введіть коректний email.")
elif order_data['state'] == COMMENTS:
order_data['comments'] = response
query.edit_message_text(text="Дякуємо за замовлення! Наш менеджер зв'яжеться з Вами найближчим часом.")
# зберігаємо замовлення у базу даних
save_order(order_data)
# очищуємо дані користувача з контексту
context.user_data.clear()
return ConversationHandler.END
# функція для збереження замовлення у базі даних
def save_order(order_data):
# створюємо об'єкт класу Order з даними про замовлення
order = Order(
service_type=order_data['service_type'],
deadline=order_data['deadline'],
customer_name=order_data['customer_name'],
customer_phone=order_data['customer_phone'],
customer_email=order_data['customer_email'],
comments=order_data['comments']
)
# підключаємося до бази даних
engine = create_engine(os.environ['DATABASE_URL'], echo=True)
Session = sessionmaker(bind=engine)
session = Session()
# додаємо замовлення до бази даних
session.add(order)
session.commit()

# закриваємо сесію
session.close()

# повертаємо текст для відправки користувачу
return "Ваше замовлення було успішно збережено. Дякуємо за звернення до нас!"
функція для очищення контексту після завершення діалогу
def end_conversation(update: Update, context: CallbackContext):
context.user_data.clear()
update.message.reply_text("До зустрічі!")

# функція для обробки невідомих команд
def unknown_command(update: Update, context: CallbackContext):
update.message.reply_text("Вибачте, я не розумію цю команду.")

# функція для обробки помилок
def error_handler(update: Update, context: CallbackContext):
logger.error(msg="Exception occured", exc_info=context.error)
# надсилаємо повідомлення про помилку до користувача
update.message.reply_text("Сталася помилка під час обробки запиту. Спробуйте ще раз пізніше.")
функція для створення екземпляру класу Updater та налаштування обробки запитів
def main():
# створюємо екземпляр класу Updater
updater = Updater(token=os.environ['TELEGRAM_BOT_TOKEN'], use_context=True)
# отримуємо об'єкт диспетчера
dp = updater.dispatcher

# реєструємо обробник команди /start
dp.add_handler(CommandHandler('start', start_command))

# реєструємо обробник команди /help
dp.add_handler(CommandHandler('help', help_command))

# реєструємо обробник команди /cancel
dp.add_handler(CommandHandler('cancel', cancel_command))

# реєструємо обробник повідомлень з кнопками
elif order_data['state'] == COMMENTS:
    order_data['comments'] = response
    query.edit_message_text(text=f"Коментарій: {response}\n\nВаше замовлення:\n{order_data}\n\nВи впевнені, що хочете зробити замовлення?")
    order_data['state'] = CONFIRMATION

# підтвердження замовлення
elif order_data['state'] == CONFIRMATION:
    if response.lower() in ['так', 'да', 'yes']:
        save_order(order_data)
        query.edit_message_text(text=f"Замовлення збережено. Дякуємо за звернення!")
        # очищуємо дані користувача
        del context.user_data['order_data']
        return ConversationHandler.END
    else:
        query.edit_message_text(text="Замовлення не збережено. Можете почати замовлення знову.")
        # очищуємо дані користувача
        del context.user_data['order_data']
        return ConversationHandler.END
функція для перевірки валідності email
def validate_email(email):
if len(email) > 7:
if re.match(r'^[\w.+-]+@[\w]+.[a-z]{2,3}$', email):
return True
return False

створюємо функцію main, яка буде викликатись при запуску скрипту
def main():
# створюємо об'єкт класу Updater
updater = Updater(token=TOKEN, use_context=True)
# створюємо об'єкт класу Dispatcher
dispatcher = updater.dispatcher

# створюємо об'єкт класу ConversationHandler
conv_handler = ConversationHandler(
    entry_points=[CommandHandler('start', start)],
    states={
        CHOOSING: [CallbackQueryHandler(choose_service_type, pattern='^' + str(i) + '$') for i in range(len(SERVICE_TYPES))],
        TYPING: [MessageHandler(Filters.text & ~Filters.command, get_deadline)],
        DEADLINE: [MessageHandler(Filters.text & ~Filters.command, get_name)],
        PHONE: [MessageHandler(Filters.text & ~Filters.command, get_phone)],
        EMAIL: [MessageHandler(Filters.text & ~Filters.command & Filters.regex(r'^.+@.+\..+$'), get_email)],
        COMMENTS: [MessageHandler(Filters.text & ~Filters.command, get_comments)],
        CONFIRMATION: [MessageHandler(Filters.text & ~Filters.command, confirmation)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],
)

# додаємо обробник діалогу до диспетчера
dispatcher.add_handler(conv_handler)

# запускаємо бота
updater.start_polling()

# додаємо обробник сигналу завершення роботи програми
updater.idle()
# створюємо об'єкт класу Dispatcher
dispatcher = updater.dispatcher

# створюємо об'єкт класу ConversationHandler
conv_handler = ConversationHandler(
    entry_points=[CommandHandler('start', start)],
    states={
        CHOOSING: [CallbackQueryHandler(choose_service_type, pattern='^' + str(i) + '$') for i in range(len(SERVICE_TYPES))],
        TYPING: [MessageHandler(Filters.text & ~Filters.command, get_deadline)],
        DEADLINE: [MessageHandler(Filters.text & ~Filters.command, get_name)],
        PHONE: [MessageHandler(Filters.text & ~Filters.command, get_phone)],
        EMAIL: [MessageHandler(Filters.text & ~Filters.command & Filters.regex(r'^.+@.+\..+$'), get_email)],
        COMMENTS: [MessageHandler(Filters.text & ~Filters.command, get_comments)],
        CONFIRMATION: [MessageHandler(Filters.text & ~Filters.command, confirmation)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],
)

# додаємо обробник діалогу до диспетчера
dispatcher.add_handler(conv_handler)

# запускаємо бота
updater.start_polling()

# додаємо обробник сигналу завершення роботи програми
updater.idle()

if __name__ == '__main__':
    main()

# функція для підтвердження замовлення та відправки його адміністратору
def confirm_order(update, context):
user_data = context.user_data
order_data = user_data['order_data']
order_text = f'Нове замовлення:\n'
for key, value in order_data.items():
order_text += f'{key}: {value}\n'
# відправляємо підтвердження замовлення користувачу
update.message.reply_text('Дякуємо! Ваше замовлення прийнято.')
# відправляємо замовлення адміністратору
context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=order_text)
# очищуємо дані користувача
user_data.clear()
return ConversationHandler.END

# функція для скасування замовлення та очищення даних користувача
def cancel_order(update, context):
user_data = context.user_data
user_data.clear()
update.message.reply_text('Замовлення скасовано.')
return ConversationHandler.END

# створюємо об'єкт типу ConversationHandler для обробки діалогу з користувачем
conv_handler = ConversationHandler(
entry_points=[CommandHandler('start', start)],
states={
GET_TOPIC: [MessageHandler(Filters.text & ~Filters.command, get_topic)],
GET_PAGES: [MessageHandler(Filters.text & ~Filters.command, get_pages)],
GET_DEADLINE: [MessageHandler(Filters.text & ~Filters.command, get_deadline)],
GET_COMMENTS: [MessageHandler(Filters.text & ~Filters.command, get_comments)],
GET_CUSTOMER_NAME: [MessageHandler(Filters.text & ~Filters.command, get_customer_name)],
GET_CUSTOMER_PHONE: [MessageHandler(Filters.text & ~Filters.command, get_customer_phone)],
CONFIRM: [MessageHandler(Filters.regex('^(так|ні)$'), confirm)],
},
fallbacks=[CommandHandler('cancel', cancel_order)],
)

# створюємо об'єкт типу Updater та реєструємо обробники подій
updater = Updater(TOKEN, use_context=True)
updater.dispatcher.add_handler(conv_handler)

# запускаємо бота
updater.start_polling()
updater.idle()
